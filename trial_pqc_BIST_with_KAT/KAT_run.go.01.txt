// main.go - KAT (Known Answer Test) demo for PQC algorithms
package main

import (
	"crypto/subtle"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"pqc_bist_demo/ciphering"
	"pqc_bist_demo/hashing"
	"pqc_bist_demo/signing"
	"pqc_bist_demo/util"
)

// TestVector represents a single test vector from the JSON file
type TestVector struct {
	ID             string `json:"id"`
	Algorithm      string `json:"algorithm"`
	SecurityLevel  string `json:"security_level"`
	PublicKey      string `json:"public_key,omitempty"`
	PrivateKey     string `json:"private_key,omitempty"`
	Ciphertext     string `json:"ciphertext,omitempty"`
	SharedSecret   string `json:"shared_secret,omitempty"`
	Signature      string `json:"signature,omitempty"`
	Message        string `json:"message,omitempty"`
	Hash           string `json:"hash,omitempty"`
	InputData      string `json:"input_data,omitempty"`
	ExpectedResult bool   `json:"expected_result"`
	Description    string `json:"description"`
}

// KATSuite holds all test vectors loaded from JSON
type KATSuite struct {
	TestVectors []TestVector
	Results     map[string]bool
	Errors      []string
}

func KAT_main() {
	fmt.Println("=== Post-Quantum Cryptography KAT Demo ===")

	// Load KAT vectors
	katSuite, err := loadKATVectors("pqc_test_vectors.json")
	if err != nil {
		log.Fatalf("Failed to load KAT vectors: %v", err)
	}

	fmt.Printf("Loaded %d test vectors\n", len(katSuite.TestVectors))

	// Run KAT demos
	runKATDemos(katSuite)

	// Print results
	printKATResults(katSuite)
}

// loadKATVectors loads test vectors from JSON file
func loadKATVectors(filename string) (*KATSuite, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}

	var testVectors []TestVector
	if err := json.Unmarshal(data, &testVectors); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	return &KATSuite{
		TestVectors: testVectors,
		Results:     make(map[string]bool),
		Errors:      make([]string, 0),
	}, nil
}

// runKATDemos runs all KAT demo functions
func runKATDemos(suite *KATSuite) {
	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Println("RUNNING KNOWN ANSWER TESTS (KAT)")
	fmt.Println(strings.Repeat("=", 60))

	for _, tv := range suite.TestVectors {
		fmt.Printf("\nRunning test: %s (%s)\n", tv.ID, tv.Description)
		fmt.Println(strings.Repeat("-", 40))

		var success bool
		var err error

		switch {
		case strings.HasPrefix(tv.ID, "KEM-"):
			success, err = demo_KAT_KEM(tv)
		case strings.HasPrefix(tv.ID, "SIG-"):
			success, err = demo_KAT_Signature(tv)
		case strings.HasPrefix(tv.ID, "HASH-"):
			success, err = demo_KAT_Hash(tv)
		default:
			err = fmt.Errorf("unknown test vector type: %s", tv.ID)
		}

		if err != nil {
			suite.Errors = append(suite.Errors, fmt.Sprintf("%s: %v", tv.ID, err))
			suite.Results[tv.ID] = false
			fmt.Printf("‚ùå FAILED: %v\n", err)
		} else {
			suite.Results[tv.ID] = success
			if success {
				fmt.Printf("‚úÖ PASSED\n")
			} else {
				fmt.Printf("‚ùå FAILED: Result mismatch\n")
			}
		}
	}
}

// demo_KAT_KEM demonstrates KEM operations using known test vectors
func demo_KAT_KEM(tv TestVector) (bool, error) {
	fmt.Printf("üîê KEM Test: %s\n", tv.Algorithm)

	// Decode hex strings
	pubKeyBytes, err := hex.DecodeString(tv.PublicKey)
	if err != nil {
		return false, fmt.Errorf("failed to decode public key: %w", err)
	}

	privKeyBytes, err := hex.DecodeString(tv.PrivateKey)
	if err != nil {
		return false, fmt.Errorf("failed to decode private key: %w", err)
	}

	ciphertextBytes, err := hex.DecodeString(tv.Ciphertext)
	if err != nil {
		return false, fmt.Errorf("failed to decode ciphertext: %w", err)
	}

	expectedSharedSecret, err := hex.DecodeString(tv.SharedSecret)
	if err != nil {
		return false, fmt.Errorf("failed to decode shared secret: %w", err)
	}

	// Display test vector info
	fmt.Printf("  Public Key Length: %d bytes\n", len(pubKeyBytes))
	fmt.Printf("  Private Key Length: %d bytes\n", len(privKeyBytes))
	fmt.Printf("  Ciphertext Length: %d bytes\n", len(ciphertextBytes))
	fmt.Printf("  Expected Shared Secret Length: %d bytes\n", len(expectedSharedSecret))

	// Perform decapsulation
	recoveredSecret, err := ciphering.Decapsulate(privKeyBytes, ciphertextBytes)
	if err != nil {
		if tv.ExpectedResult {
			return false, fmt.Errorf("decapsulation failed unexpectedly: %w", err)
		}
		// Expected to fail
		fmt.Printf("  Decapsulation failed as expected: %v\n", err)
		return true, nil
	}

	fmt.Printf("  Recovered Shared Secret Length: %d bytes\n", len(recoveredSecret))

	// Compare shared secrets using constant-time comparison
	match := subtle.ConstantTimeCompare(expectedSharedSecret, recoveredSecret) == 1

	if tv.ExpectedResult {
		if match {
			fmt.Printf("  Shared secrets match: ‚úÖ\n")
			fmt.Printf("  Expected: %x\n", expectedSharedSecret[:min(16, len(expectedSharedSecret))])
			fmt.Printf("  Got:      %x\n", recoveredSecret[:min(16, len(recoveredSecret))])
			return true, nil
		} else {
			fmt.Printf("  Shared secrets do not match: ‚ùå\n")
			fmt.Printf("  Expected: %x\n", expectedSharedSecret[:min(16, len(expectedSharedSecret))])
			fmt.Printf("  Got:      %x\n", recoveredSecret[:min(16, len(recoveredSecret))])
			return false, nil
		}
	} else {
		// Expected to produce different result
		if !match {
			fmt.Printf("  Shared secrets correctly do not match: ‚úÖ\n")
			return true, nil
		} else {
			fmt.Printf("  Shared secrets unexpectedly match: ‚ùå\n")
			return false, nil
		}
	}
}

// demo_KAT_Signature demonstrates signature operations using known test vectors
func demo_KAT_Signature(tv TestVector) (bool, error) {
	fmt.Printf("‚úçÔ∏è Signature Test: %s\n", tv.Algorithm)

	// Decode hex strings
	pubKeyBytes, err := hex.DecodeString(tv.PublicKey)
	if err != nil {
		return false, fmt.Errorf("failed to decode public key: %w", err)
	}

	signatureBytes, err := hex.DecodeString(tv.Signature)
	if err != nil {
		return false, fmt.Errorf("failed to decode signature: %w", err)
	}

	// For signature tests, we'll use a fixed message or decode from hex if provided
	var message []byte
	if tv.Message != "" {
		if strings.HasPrefix(tv.Message, "hex:") {
			message, err = hex.DecodeString(tv.Message[4:])
			if err != nil {
				return false, fmt.Errorf("failed to decode message: %w", err)
			}
		} else {
			message = []byte(tv.Message)
		}
	} else {
		// Use a default test message for signature type 0
		message = []byte("test message for signature verification")
	}

	// Display test vector info
	fmt.Printf("  Public Key Length: %d bytes\n", len(pubKeyBytes))
	fmt.Printf("  Signature Length: %d bytes\n", len(signatureBytes))
	fmt.Printf("  Message Length: %d bytes\n", len(message))
	fmt.Printf("  Message: %s\n", string(message[:min(50, len(message))]))

	// Verify signature
	valid, err := signing.Verify(pubKeyBytes, message, signatureBytes)
	if err != nil {
		if tv.ExpectedResult {
			return false, fmt.Errorf("signature verification failed unexpectedly: %w", err)
		}
		// Expected to fail
		fmt.Printf("  Signature verification failed as expected: %v\n", err)
		return true, nil
	}

	fmt.Printf("  Signature Valid: %v\n", valid)

	if tv.ExpectedResult {
		if valid {
			fmt.Printf("  Signature verification succeeded: ‚úÖ\n")
			return true, nil
		} else {
			fmt.Printf("  Signature verification failed: ‚ùå\n")
			return false, nil
		}
	} else {
		// Expected to be invalid
		if !valid {
			fmt.Printf("  Signature correctly invalid: ‚úÖ\n")
			return true, nil
		} else {
			fmt.Printf("  Signature unexpectedly valid: ‚ùå\n")
			return false, nil
		}
	}
}

// demo_KAT_Hash demonstrates hash operations using known test vectors
func demo_KAT_Hash(tv TestVector) (bool, error) {
	fmt.Printf("üè∑Ô∏è Hash Test: %s\n", tv.Algorithm)

	// Decode input data
	var inputData []byte
	var err error
	if tv.InputData != "" {
		if strings.HasPrefix(tv.InputData, "hex:") {
			inputData, err = hex.DecodeString(tv.InputData[4:])
		} else {
			inputData = []byte(tv.InputData)
		}
	} else {
		inputData = []byte("default test data for hashing")
	}

	if err != nil {
		return false, fmt.Errorf("failed to decode input data: %w", err)
	}

	// Decode expected hash
	expectedHash, err := hex.DecodeString(tv.Hash)
	if err != nil {
		return false, fmt.Errorf("failed to decode expected hash: %w", err)
	}

	// Determine security level from algorithm
	level := getSecurityLevelFromAlgorithm(tv.Algorithm)

	// Display test vector info
	fmt.Printf("  Input Data Length: %d bytes\n", len(inputData))
	fmt.Printf("  Expected Hash Length: %d bytes\n", len(expectedHash))
	fmt.Printf("  Security Level: %s\n", level.String())

	// Compute hash
	computedHash, err := hashing.Hash(inputData, level)
	if err != nil {
		return false, fmt.Errorf("hash computation failed: %w", err)
	}

	fmt.Printf("  Computed Hash Length: %d bytes\n", len(computedHash))

	// Compare hashes
	match := subtle.ConstantTimeCompare(expectedHash, computedHash) == 1

	if match {
		fmt.Printf("  Hash values match: ‚úÖ\n")
		fmt.Printf("  Expected: %x\n", expectedHash[:min(16, len(expectedHash))])
		fmt.Printf("  Got:      %x\n", computedHash[:min(16, len(computedHash))])
		return tv.ExpectedResult, nil
	} else {
		fmt.Printf("  Hash values do not match: ‚ùå\n")
		fmt.Printf("  Expected: %x\n", expectedHash[:min(16, len(expectedHash))])
		fmt.Printf("  Got:      %x\n", computedHash[:min(16, len(computedHash))])
		return !tv.ExpectedResult, nil
	}
}

// getSecurityLevelFromAlgorithm maps algorithm names to security levels
func getSecurityLevelFromAlgorithm(algorithm string) util.SecurityLevel {
	switch {
	case strings.Contains(algorithm, "512") || strings.Contains(algorithm, "2"):
		return util.Level128
	case strings.Contains(algorithm, "768") || strings.Contains(algorithm, "3"):
		return util.Level192
	case strings.Contains(algorithm, "1024") || strings.Contains(algorithm, "5"):
		return util.Level256
	case strings.Contains(algorithm, "SHAKE128"):
		return util.Level128
	case strings.Contains(algorithm, "SHAKE256"):
		return util.Level192
	case strings.Contains(algorithm, "SHA3-256"):
		return util.Level256
	default:
		return util.Level192 // Default
	}
}

// printKATResults prints a summary of all KAT results
func printKATResults(suite *KATSuite) {
	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Println("KAT RESULTS SUMMARY")
	fmt.Println(strings.Repeat("=", 60))

	passed := 0
	failed := 0

	// Count by category
	kemTests := 0
	kemPassed := 0
	sigTests := 0
	sigPassed := 0
	hashTests := 0
	hashPassed := 0

	for id, result := range suite.Results {
		if result {
			passed++
		} else {
			failed++
		}

		switch {
		case strings.HasPrefix(id, "KEM-"):
			kemTests++
			if result {
				kemPassed++
			}
		case strings.HasPrefix(id, "SIG-"):
			sigTests++
			if result {
				sigPassed++
			}
		case strings.HasPrefix(id, "HASH-"):
			hashTests++
			if result {
				hashPassed++
			}
		}
	}

	fmt.Printf("Overall Results:\n")
	fmt.Printf("  Total Tests: %d\n", len(suite.Results))
	fmt.Printf("  Passed: %d ‚úÖ\n", passed)
	fmt.Printf("  Failed: %d ‚ùå\n", failed)
	fmt.Printf("  Success Rate: %.1f%%\n", float64(passed)/float64(len(suite.Results))*100)

	fmt.Printf("\nResults by Category:\n")
	if kemTests > 0 {
		fmt.Printf("  KEM Tests: %d/%d passed (%.1f%%)\n", kemPassed, kemTests, float64(kemPassed)/float64(kemTests)*100)
	}
	if sigTests > 0 {
		fmt.Printf("  Signature Tests: %d/%d passed (%.1f%%)\n", sigPassed, sigTests, float64(sigPassed)/float64(sigTests)*100)
	}
	if hashTests > 0 {
		fmt.Printf("  Hash Tests: %d/%d passed (%.1f%%)\n", hashPassed, hashTests, float64(hashPassed)/float64(hashTests)*100)
	}

	if len(suite.Errors) > 0 {
		fmt.Printf("\nErrors Encountered:\n")
		for _, err := range suite.Errors {
			fmt.Printf("  - %s\n", err)
		}
	}

	// Save results to file
	saveKATResults(suite)

	fmt.Printf("\n" + strings.Repeat("=", 60))
	if failed == 0 {
		fmt.Println("üéâ ALL KAT TESTS PASSED!")
	} else {
		fmt.Printf("‚ö†Ô∏è  %d TESTS FAILED - REVIEW REQUIRED\n", failed)
	}
	fmt.Println(strings.Repeat("=", 60))
}

// saveKATResults saves the test results to a JSON file
func saveKATResults(suite *KATSuite) {
	results := map[string]interface{}{
		"timestamp": time.Now().Format(time.RFC3339),
		"summary": map[string]interface{}{
			"total_tests": len(suite.Results),
			"passed":      0,
			"failed":      0,
		},
		"test_results": suite.Results,
		"errors":       suite.Errors,
	}

	// Count passed/failed
	for _, result := range suite.Results {
		if result {
			results["summary"].(map[string]interface{})["passed"] = results["summary"].(map[string]interface{})["passed"].(int) + 1
		} else {
			results["summary"].(map[string]interface{})["failed"] = results["summary"].(map[string]interface{})["failed"].(int) + 1
		}
	}

	// Marshal to JSON
	jsonData, err := json.MarshalIndent(results, "", "  ")
	if err != nil {
		log.Printf("Failed to marshal results: %v", err)
		return
	}

	// Write to file
	filename := fmt.Sprintf("kat_results_%s.json", time.Now().Format("20060102_150405"))
	if err := os.WriteFile(filename, jsonData, 0644); err != nil {
		log.Printf("Failed to write results file: %v", err)
	} else {
		fmt.Printf("\nResults saved to: %s\n", filename)
	}
}
